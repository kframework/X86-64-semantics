module FLOAT-CONVERSIONS
  imports STRING
  imports INT
  imports MINT
  imports FLOAT
  imports FLOAT-SYNTAX

  syntax Bool ::= isPositiveZero(Float) [function]
  rule isPositiveZero(F:Float) => true
    requires SignBit(F) ==Int 0 andBool MantissaFloat(F) ==Int 0 andBool ExponentBitVectorFloat(F) ==Int 0
  rule isPositiveZero(F:Float) => false
    requires notBool( SignBit(F) ==Int 0 andBool MantissaFloat(F) ==Int 0 andBool ExponentBitVectorFloat(F) ==Int 0)

  syntax Bool ::= isNegativeZero(Float) [function]
  rule isNegativeZero(F:Float) => true
    requires SignBit(F) ==Int 1 andBool MantissaFloat(F) ==Int 0 andBool ExponentBitVectorFloat(F) ==Int 0
  rule isNegativeZero(F:Float) => false
    requires notBool( SignBit(F) ==Int 1 andBool MantissaFloat(F) ==Int 0 andBool ExponentBitVectorFloat(F) ==Int 0)

  syntax Bool ::= isZero(Float) [function]
  rule isZero(F:Float) => true
    requires isPositiveZero(F) orBool isNegativeZero(F)
  rule isZero(F:Float) => false
    requires notBool ( isPositiveZero(F) orBool isNegativeZero(F) )


  syntax Float ::= GetInfinity(Int, Int) [function] // Dumb hack because Kompile won't parse Infinity/NaN as a float.
  rule GetInfinity(Mlen, Elen) => roundFloat(1.0 /Float 0.0, Mlen, Elen)
  
  syntax Float ::= GetNaN(Int, Int) [function] // See above.
  rule GetNaN(Mlen, Elen) => roundFloat(0.0 /Float 0.0, Mlen, Elen)

  syntax Int ::= MinimumFloatingPointExponent(Int) [function] // Gets the smallest floating point exponent representable with E bits.
  rule MinimumFloatingPointExponent(E) => 2 -Int (2 ^Int (E -Int 1))

  syntax Float ::= MinimumNormalizedFloat(Int, Int) [function] // Gets the smallest normalized floating point representable with P bits of precision and E bits of exponent
  rule MinimumNormalizedFloat(P, E) => roundFloat(2.0, P, E) ^Float Int2Float(MinimumFloatingPointExponent(E), P, E)

  syntax Int ::= MantissaFloat(Float) [function]

  rule MantissaFloat(F) => 0 requires isInfinite(F) // Infinities' mantissas must be zero.

  // The following value, chosen for the mantissa of a NaN, is arbitrary and
  // may differ from the corresponsing representation in machine.
  rule MantissaFloat(F) => 1 requires isNaN(F)

  // We observe that the following NaN mantissa value is generated by machine
  // when non-NaN operands are involved. For example, 0.0/0.0 generates the
  // folowing NaN mantisa value. When the NaN opearnds are involved (like in
  // NaN1/NaN2), the mantisaa value could be NaN1 or NaN2.
  // rule MantissaFloat(F) => 1 <<Int (precisionFloat(F) -Int 2) requires isNaN(F)

  rule MantissaFloat(F) => MantissaFloat(absFloat(F) +Float MinimumNormalizedFloat(precisionFloat(F), exponentBitsFloat(F)))
  requires absFloat(F) <Float MinimumNormalizedFloat(precisionFloat(F), exponentBitsFloat(F)) 
  // We simply avoid dealing with denormalized floating point numbers by transforming them to normalized floats with the same mantissa.

  rule MantissaFloat(F) => Float2Int(
    roundFloat(absFloat(F), precisionFloat(F), exponentBitsFloat(F) +Int 2) 
    *Float (roundFloat(2.0, precisionFloat(F), exponentBitsFloat(F) +Int 2) ^Float Int2Float(precisionFloat(F) -Int 1 -Int exponentFloat(F), precisionFloat(F), exponentBitsFloat(F) +Int 2))
  ) &Int ((1 <<Int (precisionFloat(F) -Int 1)) -Int 1) [owise]
  // First, get rid of the sign bit.  
  // Next, multiply by 2^-Exponent to zero the exponent (getting a fixed point of 1.MantissaBits)
  // Then multiply by 2^#NumMantissaBits (Getting a float of 1(MantissaBits).0)
  // Then, convert to an int.
  // Then Mask out the uppermost 1.  This yields an int containing the Mantissa of the original float.

  syntax Int ::= MIntToSignBit(MInt) [function]
  rule MIntToSignBit(MI) => uvalueMInt(extractMInt(MI, 0, 1)) 

  syntax Int ::= MIntToExponentBits(MInt, Int) [function]
  rule MIntToExponentBits(M, E) => uvalueMInt(extractMInt(M, 1, 1 +Int E))

  syntax Int ::= MIntToMantissaBits(MInt, Int, Int) [function]
  rule MIntToMantissaBits(MI, E, M) => uvalueMInt(extractMInt(MI, 1 +Int E, E +Int M)) 

  syntax Int ::= MaxExponent(Int) [function] // Max logical exponent allowed with I exponent bits.
  rule MaxExponent(I) => 1 <<Int (I -Int 1) 

  syntax Int ::= MaxExponentBits(Int) [function] // Max unsigned value allowed in I exponent bits.
  rule MaxExponentBits(I) => (1 <<Int I) -Int 1

  syntax Int ::= MinExponent(Int) [function] // Min logical exponent allowed in I exponent bits.
  rule MinExponent(I) => 2 -Int MaxExponent(I) // Yes, 2.  Denormalized numbers and zero.

  syntax Float ::= SignBitToSign(Int, Int, Int) [function]
  rule SignBitToSign(M, E, B) => Int2Float(1 -Int (B *Int 2), M, E)

  syntax Int ::= ExponentBitsToExponent(Int, Int) [function] 
  rule ExponentBitsToExponent(Elen, E) => minInt(maxInt(E -Int MaxExponent(Elen) +Int 1, MinExponent(Elen)), MaxExponent(Elen))

  syntax Float ::= ExponentBitsToExponentMultiplier(Int, Int, Int) [function]
  rule ExponentBitsToExponentMultiplier(Mlen, Elen, E) 
    => 
  roundFloat(2.0, Mlen, Elen) ^Float Int2Float(ExponentBitsToExponent(Elen, E), Mlen, Elen)

  syntax Float ::= MantissaBitsToFixedPoint(Int, Int, Int, Int) [function] 
  rule MantissaBitsToFixedPoint(Mlen, Elen, M, I) //I=1 for normalized, I=0 for denormalized.
    =>
  Int2Float((I <<Int (Mlen -Int 1)) |Int M, Mlen, Elen) /Float 
  (
    roundFloat(2.0, Mlen, Elen) ^Float
    Int2Float(Mlen -Int 1, Mlen, Elen)
  )

  syntax Float ::= MIntSegmentsToFloatNormalized(Int, Int, Int, Int, Int) [function]
  rule MIntSegmentsToFloatNormalized(Mlen, Elen, S, E, M)
    =>
    roundFloat(
  SignBitToSign(Mlen, Elen, S) *Float
  ExponentBitsToExponentMultiplier(Mlen, Elen, E) *Float
  MantissaBitsToFixedPoint(Mlen, Elen, M, 1), Mlen, Elen)

  syntax Float ::= MIntSegmentsToFloatDenormalized(Int, Int, Int, Int, Int) [function]
  rule MIntSegmentsToFloatDenormalized(Mlen, Elen, S, _, M)
    =>
    roundFloat(
  SignBitToSign(Mlen, Elen, S) *Float
  ExponentBitsToExponentMultiplier(Mlen, Elen, MinExponent(Elen)) *Float
  MantissaBitsToFixedPoint(Mlen, Elen, M, 0), Mlen, Elen)

  syntax Float ::= MIntToFloatImpl(Int, Int, Int, Int, Int) [function]
  rule MIntToFloatImpl(Mlen, Elen, S, E, 0) 
    => 
  SignBitToSign(Mlen, Elen, S) *Float roundFloat(GetInfinity(Mlen, Elen), Mlen, Elen) 
  requires E ==Int MaxExponentBits(Elen)

  rule MIntToFloatImpl(Mlen, Elen, _, E, M) => roundFloat(GetNaN(Mlen, Elen), Mlen, Elen) 
  requires E ==Int MaxExponentBits(Elen) andBool M >Int 0

  rule MIntToFloatImpl(Mlen, Elen, S, E, M) 
    => 
  MIntSegmentsToFloatNormalized(Mlen, Elen, S, E, M)
  requires E >Int 0 andBool E <Int MaxExponentBits(Elen)

  rule MIntToFloatImpl(Mlen, Elen, S, 0, M) 
    => 
  MIntSegmentsToFloatDenormalized(Mlen, Elen, S, 0, M)

  syntax Float ::= MInt2Float(MInt, Int, Int) [function] // Value, Mantissa, Exponent
  rule MInt2Float(MI, M, E) => MIntToFloatImpl(M, E, 
    MIntToSignBit(MI),
    MIntToExponentBits(MI, E),
    MIntToMantissaBits(MI, E, M)
  )
  requires bitwidthMInt(MI) ==Int M +Int E andBool M >=Int 2 andBool E >=Int 2

  syntax MInt ::= Float2MInt(Float, Int) [function]

  syntax Int ::= ExponentBitVectorFloat(Float) [function]
  
  rule ExponentBitVectorFloat(F) => 0 requires absFloat(F) <Float MinimumNormalizedFloat(precisionFloat(F), exponentBitsFloat(F))
  rule ExponentBitVectorFloat(F) => (1 <<Int exponentBitsFloat(F)) -Int 1 requires isInfinite(F) orBool isNaN(F)
  rule ExponentBitVectorFloat(F) => exponentFloat(F) +Int (1 <<Int (exponentBitsFloat(F) -Int 1)) -Int 1 [owise] 

  syntax Int ::= SignBit(Float) [function]

  // rule SignBit(F) => 1 requires isNaN(F) // The choice of `1` sign bit for NaN
                                            // is based on the actual machine's
                                            // NaN representation.
  // rule SignBit(F) => 0 requires notBool signFloat(F) andBool (notBool isNaN(F))
  // rule SignBit(F) => 1 requires signFloat(F) andBool (notBool isNaN(F))

  rule SignBit(F) => 0 requires notBool signFloat(F)
  rule SignBit(F) => 1 requires signFloat(F)

  rule Float2MInt(F, 16) => mi(16, (SignBit(F) <<Int 15) |Int (ExponentBitVectorFloat(F) <<Int 10) |Int MantissaFloat(F)) 
  requires precisionFloat(F) ==Int 11 andBool exponentBitsFloat(F) ==Int 5

  rule Float2MInt(F, 32) => mi(32, (SignBit(F) <<Int 31) |Int (ExponentBitVectorFloat(F) <<Int 23) |Int MantissaFloat(F))
  requires precisionFloat(F) ==Int 24 andBool exponentBitsFloat(F) ==Int 8

  rule Float2MInt(F, 64) => mi(64, (SignBit(F) <<Int 63) |Int (ExponentBitVectorFloat(F) <<Int 52) |Int MantissaFloat(F))
  requires precisionFloat(F) ==Int 53 andBool exponentBitsFloat(F) ==Int 11

  syntax Float ::= Float2Double(Float) [function]
  rule Float2Double(F) => roundFloat(F, 53, 11)

  syntax Float ::= Double2Float(Float) [function]
  rule Double2Float(F) => roundFloat(F, 24, 8)

  syntax Float ::= Half2Float(Float) [function]
  rule Half2Float(F) => roundFloat(F, 24, 8)

  syntax Float ::= SignMultFloat(Float) [function]
  rule SignMultFloat(F) => roundFloat(1.0, precisionFloat(F), exponentBitsFloat(F)) requires F >=Float roundFloat(0.0, precisionFloat(F), exponentBitsFloat(F))
  rule SignMultFloat(F) => roundFloat(-1.0, precisionFloat(F), exponentBitsFloat(F)) requires F <Float roundFloat(0.0, precisionFloat(F), exponentBitsFloat(F))

  syntax Float ::= ExponentMultFloat(Float) [function]
  rule ExponentMultFloat(F) => Int2Float(2, precisionFloat(F), exponentBitsFloat(F)) ^Float Int2Float(exponentFloat(F), precisionFloat(F), exponentBitsFloat(F))

  syntax Int ::= ConvertExponent(Int) [function]
  rule ConvertExponent(I) => 0 requires I <Int -14
  rule ConvertExponent(I) => 31 requires I >=Int 16
  rule ConvertExponent(I) => I +Int 15 [owise]

  syntax Int ::= ConvertMantissa(Float) [function]
  rule ConvertMantissa(F) => 0 requires absFloat(F) >Float roundFloat(maxValueFloat(11, 5), precisionFloat(F), exponentBitsFloat(F)) // Should go to Infinity, whose Mantissa is 0.
  rule ConvertMantissa(F) => 0 requires absFloat(F) <Float roundFloat(minValueFloat(11, 5), precisionFloat(F), exponentBitsFloat(F)) // Should go to zero, whose Mantissa is 0.

  rule ConvertMantissa(F) => ((1 <<Int (precisionFloat(F) -Int 1)) |Int MantissaFloat(F)) >>Int (precisionFloat(F) -Int 11 +Int (-14 -Int exponentFloat(F))) // Should denormalize in destination, need to make implicit 1 explicit.
  requires 
    absFloat(F) >=Float roundFloat(minValueFloat(11, 5), precisionFloat(F), exponentBitsFloat(F)) andBool
    absFloat(F) <Float roundFloat(MinimumNormalizedFloat(11, 5), precisionFloat(F), exponentBitsFloat(F))
  
  rule ConvertMantissa(F) => MantissaFloat(F) >>Int (precisionFloat(F) -Int 11) [owise] // Should remain normal

  syntax Float ::= roundAwayFromZero(Float) [function]
  rule roundAwayFromZero(F) => MInt2Float(mi(16, (SignBit(F) <<Int 15) |Int (ConvertExponent(exponentFloat(F)) <<Int 10) |Int (ConvertMantissa(F) +Int CorrectionFromZero(MantissaFloat(F) &Int ((1 <<Int precisionFloat(F) -Int 11) -Int 1)))), 11, 5)

  syntax Int ::= CorrectionFromZero(Int) [function]
  rule CorrectionFromZero(0) => 0
  rule CorrectionFromZero(_) => 1 [owise]


  syntax Float ::= roundToZero(Float) [function]
  rule roundToZero(F) => MInt2Float(mi(16, (SignBit(F) <<Int 15) |Int (ConvertExponent(exponentFloat(F)) <<Int 10) |Int ConvertMantissa(F)), 11, 5)

  syntax Float ::= Float2Half(Float, Int) [function]
  rule Float2Half(F, 0) => roundFloat(F, 11, 5) // This should work but doesn't (we wind up multiplying the float by 2?).  Bug in the ocaml backend - java works just fine?

/*  rule Float2Half(F, 1) => GetNaN(11, 5) requires isNaN(F)
  rule Float2Half(F, 1) => GetNaN(11, 5) requires F >Float maxValueFloat(precisionFloat(F), exponentBitsFloat(F))
  rule Float2Half(F, 1) => --Float GetInfinity(11, 5) requires F <Float --Float maxValueFloat(precisionFloat(F), exponentBitsFloat(F))*/ 
  // Need to work on handling of NaNs and Infinities.  In theory, these are well defined (my code just doesn't handle these cases... do we actually care?)

  rule Float2Half(F, 1) => roundToZero(F) requires notBool signFloat(F) 
  rule Float2Half(F, 1) => roundAwayFromZero(F) requires signFloat(F)
  
  rule Float2Half(F, 2) => roundAwayFromZero(F) requires notBool signFloat(F) 
  rule Float2Half(F, 2) => roundToZero(F) requires signFloat(F)
  rule Float2Half(F, 3) => roundToZero(F)

  syntax Float ::= negateFloat(Float) [function]
  rule negateFloat(F) => --Float F

endmodule
