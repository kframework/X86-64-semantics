// Autogenerated using stratification.
requires "x86-configuration.k"

module CMPXCHGB-M8-RH
  imports X86-CONFIGURATION

  context execinstr(cmpxchgb:Opcode R1:Rh, HOLE:Mem,  .Operands) [result(MemOffset)]
  
  rule <k>
    execinstr (cmpxchgb:Opcode R1:Rh, memOffset( MemOff:MInt):MemOffset,  .Operands) =>
      loadFromMemory( MemOff, 8) ~>
      execinstr (cmpxchgb R1:Rh, memOffset( MemOff),  .Operands)
  ...</k>
          
  rule <k>
    memLoadValue(Mem8:MInt):MemLoadValue ~> execinstr (cmpxchgb:Opcode R1:Rh, memOffset( MemOff:MInt):MemOffset,  .Operands) =>
      
            storeToMemory(
              (#ifMInt eqMInt( extractMInt( getParentValue(R1, RSMap), 56, 64), Mem8) #then extractMInt( getParentValue(R1, RSMap), 48, 56) #else Mem8 #fi),
              MemOff,
              8
            )
          
  ...</k>
    <regstate>
      RSMap:Map => updateMap(RSMap,
convToRegKeys(R1) |-> (#ifMInt eqMInt( extractMInt( getParentValue(R1, RSMap), 56, 64), Mem8) #then getParentValue(R1, RSMap) #else concatenateMInt( extractMInt( getParentValue(R1, RSMap), 0, 56), Mem8) #fi)

"CF" |-> (#ifMInt (notBool eqMInt( extractMInt( addMInt( addMInt( concatenateMInt( mi(1, 0), negMInt( Mem8)), mi(9, 1)), concatenateMInt( mi(1, 0), extractMInt( getParentValue(R1, RSMap), 56, 64))), 0, 1), mi(1, 1))) #then mi(1, 1) #else mi(1, 0) #fi)

"PF" |-> (#ifMInt (notBool (((((((eqMInt( extractMInt( addMInt( addMInt( concatenateMInt( mi(1, 0), negMInt( Mem8)), mi(9, 1)), concatenateMInt( mi(1, 0), extractMInt( getParentValue(R1, RSMap), 56, 64))), 8, 9), mi(1, 1)) xorBool eqMInt( extractMInt( addMInt( addMInt( concatenateMInt( mi(1, 0), negMInt( Mem8)), mi(9, 1)), concatenateMInt( mi(1, 0), extractMInt( getParentValue(R1, RSMap), 56, 64))), 7, 8), mi(1, 1))) xorBool eqMInt( extractMInt( addMInt( addMInt( concatenateMInt( mi(1, 0), negMInt( Mem8)), mi(9, 1)), concatenateMInt( mi(1, 0), extractMInt( getParentValue(R1, RSMap), 56, 64))), 6, 7), mi(1, 1))) xorBool eqMInt( extractMInt( addMInt( addMInt( concatenateMInt( mi(1, 0), negMInt( Mem8)), mi(9, 1)), concatenateMInt( mi(1, 0), extractMInt( getParentValue(R1, RSMap), 56, 64))), 5, 6), mi(1, 1))) xorBool eqMInt( extractMInt( addMInt( addMInt( concatenateMInt( mi(1, 0), negMInt( Mem8)), mi(9, 1)), concatenateMInt( mi(1, 0), extractMInt( getParentValue(R1, RSMap), 56, 64))), 4, 5), mi(1, 1))) xorBool eqMInt( extractMInt( addMInt( addMInt( concatenateMInt( mi(1, 0), negMInt( Mem8)), mi(9, 1)), concatenateMInt( mi(1, 0), extractMInt( getParentValue(R1, RSMap), 56, 64))), 3, 4), mi(1, 1))) xorBool eqMInt( extractMInt( addMInt( addMInt( concatenateMInt( mi(1, 0), negMInt( Mem8)), mi(9, 1)), concatenateMInt( mi(1, 0), extractMInt( getParentValue(R1, RSMap), 56, 64))), 2, 3), mi(1, 1))) xorBool eqMInt( extractMInt( addMInt( addMInt( concatenateMInt( mi(1, 0), negMInt( Mem8)), mi(9, 1)), concatenateMInt( mi(1, 0), extractMInt( getParentValue(R1, RSMap), 56, 64))), 1, 2), mi(1, 1)))) #then mi(1, 1) #else mi(1, 0) #fi)

"AF" |-> xorMInt( xorMInt( extractMInt( Mem8, 3, 4), extractMInt( getParentValue(R1, RSMap), 59, 60)), extractMInt( addMInt( addMInt( concatenateMInt( mi(1, 0), negMInt( Mem8)), mi(9, 1)), concatenateMInt( mi(1, 0), extractMInt( getParentValue(R1, RSMap), 56, 64))), 4, 5))

"ZF" |-> (#ifMInt eqMInt( extractMInt( addMInt( addMInt( concatenateMInt( mi(1, 0), negMInt( Mem8)), mi(9, 1)), concatenateMInt( mi(1, 0), extractMInt( getParentValue(R1, RSMap), 56, 64))), 1, 9), mi(8, 0)) #then mi(1, 1) #else mi(1, 0) #fi)

"SF" |-> extractMInt( addMInt( addMInt( concatenateMInt( mi(1, 0), negMInt( Mem8)), mi(9, 1)), concatenateMInt( mi(1, 0), extractMInt( getParentValue(R1, RSMap), 56, 64))), 1, 2)

"OF" |-> (#ifMInt ((eqMInt( negMInt( extractMInt( Mem8, 0, 1)), mi(1, 1)) ==Bool eqMInt( extractMInt( getParentValue(R1, RSMap), 56, 57), mi(1, 1))) andBool (notBool (eqMInt( negMInt( extractMInt( Mem8, 0, 1)), mi(1, 1)) ==Bool eqMInt( extractMInt( addMInt( addMInt( concatenateMInt( mi(1, 0), negMInt( Mem8)), mi(9, 1)), concatenateMInt( mi(1, 0), extractMInt( getParentValue(R1, RSMap), 56, 64))), 1, 2), mi(1, 1))))) #then mi(1, 1) #else mi(1, 0) #fi)
      )
    </regstate>
endmodule
