// Autogenerated using stratification.
requires "x86-configuration.k"

module PCMPESTRI-XMM-XMM-IMM8
  imports X86-CONFIGURATION

  // Find Limit Index
  rule <k>
    execinstr (pcmpestri Imm8:MInt, Xmm2:Xmm, Xmm1:Xmm,  .Operands) => 
      execinstr (pcmpestri 
          Imm8, 
          getRegisterValue(Xmm2, RSMap), 
          getRegisterValue(Xmm1, RSMap),
          findLimitIndexE(getRegisterValue(Xmm2, RSMap), getRegisterValue(%rdx, RSMap), Imm8),   
          findLimitIndexE(getRegisterValue(Xmm1, RSMap), getRegisterValue(%rax, RSMap), Imm8),   
          .Operands) 
  ...</k>
  <regstate> RSMap </regstate>
      requires bitwidthMInt(Imm8) ==Int 8

  // pcmpestri 8'1 , 128'0 , 128'0 , 8'1 , 8'1 , 8'8 , 1'0 , 8'1 , .Operands

   // Find data size and interpretation
  rule <k>
    execinstr (pcmpestri Imm8:MInt,  Value2:MInt, Value1:MInt, Limit2:MInt, Limit1:MInt, .Operands) => 
      execinstr (pcmpestri Imm8,  Value2, Value1, Limit2, Limit1,
          #ifMInt eqMInt(extractMInt(Imm8, 7, 8), mi(1, 1)) #then mi(8,8) #else mi(8, 16) #fi, 
          extractMInt(Imm8, 6, 7),  .Operands)
  ...</k>


  // Aggregation operation
  rule <k>
    execinstr (pcmpestri Imm8:MInt,  Value2:MInt, Value1:MInt, Limit2:MInt, Limit1:MInt, NumElems:MInt, SignedOrUnsigned:MInt, .Operands) => 
      execinstr (pcmpestri Imm8,  Value2, Value1, Limit2, Limit1,  NumElems, SignedOrUnsigned, equalAnyImpl(Value2, Value1, Limit2, Limit1, uvalueMInt(NumElems), SignedOrUnsigned), .Operands)
  ...</k>
    requires eqMInt(extractMInt(Imm8, 4, 6), mi(2, 0))
    
  rule <k>
    execinstr (pcmpestri Imm8:MInt,  Value2:MInt, Value1:MInt, Limit2:MInt, Limit1:MInt, NumElems:MInt, SignedOrUnsigned:MInt, .Operands) => 
      execinstr (pcmpestri Imm8,  Value2, Value1, Limit2, Limit1,  NumElems, SignedOrUnsigned, rangeImpl(Value2, Value1, Limit2, Limit1, uvalueMInt(NumElems), SignedOrUnsigned), .Operands)
  ...</k>
    requires eqMInt(extractMInt(Imm8, 4, 6), mi(2, 1))

  rule <k>
    execinstr (pcmpestri Imm8:MInt,  Value2:MInt, Value1:MInt, Limit2:MInt, Limit1:MInt, NumElems:MInt, SignedOrUnsigned:MInt, .Operands) => 
      execinstr (pcmpestri Imm8,  Value2, Value1, Limit2, Limit1,  NumElems, SignedOrUnsigned, equalEachImpl(Value2, Value1, Limit2, Limit1, uvalueMInt(NumElems), SignedOrUnsigned), .Operands)
  ...</k>
    requires eqMInt(extractMInt(Imm8, 4, 6), mi(2, 2))

  rule <k>
    execinstr (pcmpestri Imm8:MInt,  Value2:MInt, Value1:MInt, Limit2:MInt, Limit1:MInt, NumElems:MInt, SignedOrUnsigned:MInt, .Operands) => 
      execinstr (pcmpestri Imm8,  Value2, Value1, Limit2, Limit1,  NumElems, SignedOrUnsigned, equalOrderedImpl(Value2, Value1, Limit2, Limit1, uvalueMInt(NumElems), SignedOrUnsigned), .Operands)
  ...</k>
    requires eqMInt(extractMInt(Imm8, 4, 6), mi(2, 3) )   

  // Polarity
  rule <k>
    execinstr (pcmpestri Imm8:MInt,  Value2:MInt, Value1:MInt, Limit2:MInt, Limit1:MInt, NumElems:MInt, SignedOrUnsigned:MInt, IntRes1:MInt, .Operands) => 
      execinstr (pcmpestri Imm8,  Value2, Value1, Limit2, Limit1,  NumElems, 
          SignedOrUnsigned, IntRes1, 
          polarityImpl(IntRes1, Imm8, uvalueMInt(NumElems), Limit2), .Operands)
  ...</k>
      
  // Output Selection
  // If no bit is set, 16 or 8 is returned.
  rule <k>
    execinstr (pcmpestri Imm8:MInt,  Value2:MInt, Value1:MInt, Limit2:MInt, Limit1:MInt, NumElems:MInt, SignedOrUnsigned:MInt, IntRes1:MInt, IntRes2:MInt, .Operands) => 
      setRegisterValue(mi(64, uvalueMInt(NumElems)), %rcx) ~>
      setFlag(mi(1,0), "CF") ~>
      setFlag(#ifMInt ultMInt(Limit2, NumElems) #then mi(1,1) #else mi(1,0) #fi, "ZF") ~>
      setFlag(#ifMInt ultMInt(Limit1, NumElems) #then mi(1,1) #else mi(1,0) #fi, "SF") ~>
      setFlag(extractMask(IntRes2, 1, 0), "OF") ~>
      setFlag(mi(1,0), "AF") ~>
      setFlag(mi(1,0), "PF") 
  ...</k>
    requires  eqMInt(IntRes2, mi(bitwidthMInt(IntRes2), 0))

  // ELse
  rule <k>
    execinstr (pcmpestri Imm8:MInt,  Value2:MInt, Value1:MInt, Limit2:MInt, Limit1:MInt, NumElems:MInt, SignedOrUnsigned:MInt, IntRes1:MInt, IntRes2:MInt, .Operands) => 
      setRegisterValue(mi(64, scanForward(IntRes2, uvalueMInt(NumElems) -Int 1, uvalueMInt(NumElems))), %rcx) ~>
      setFlag(mi(1,1), "CF") ~>
      setFlag(#ifMInt ultMInt(Limit2, NumElems) #then mi(1,1) #else mi(1,0) #fi, "ZF") ~>
      setFlag(#ifMInt ultMInt(Limit1, NumElems) #then mi(1,1) #else mi(1,0) #fi, "SF") ~>
      setFlag(extractMask(IntRes2, 1, 0), "OF") ~>
      setFlag(mi(1,0), "AF") ~>
      setFlag(mi(1,0), "PF") 
  ...</k>
    requires eqMInt(extractMInt(Imm8, 1, 2), mi(1, 0)) 
      andBool  notBool eqMInt(IntRes2, mi(bitwidthMInt(IntRes2), 0))

  rule <k>
    execinstr (pcmpestri Imm8:MInt,  Value2:MInt, Value1:MInt, Limit2:MInt, Limit1:MInt, NumElems:MInt, SignedOrUnsigned:MInt, IntRes1:MInt, IntRes2:MInt, .Operands) => 
      setRegisterValue(mi(64, scanReverse(IntRes2, 0, uvalueMInt(NumElems))), %rcx) ~>
      setFlag(mi(1,1), "CF") ~>
      setFlag(#ifMInt ultMInt(Limit2, NumElems) #then mi(1,1) #else mi(1,0) #fi, "ZF") ~>
      setFlag(#ifMInt ultMInt(Limit1, NumElems) #then mi(1,1) #else mi(1,0) #fi, "SF") ~>
      setFlag(extractMask(IntRes2, 1, 0), "OF") ~>
      setFlag(mi(1,0), "AF") ~>
      setFlag(mi(1,0), "PF") 
  ...</k>
    requires eqMInt(extractMInt(Imm8, 1, 2), mi(1, 1) )
      andBool  notBool eqMInt(IntRes2, mi(bitwidthMInt(IntRes2), 0))
      
endmodule
