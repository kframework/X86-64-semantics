// Autogenerated using stratification.
requires "x86-configuration.k"

module SHLDW-M16-R16-CL
  imports X86-CONFIGURATION

  context execinstr (shrdw %cl, R2:R16, HOLE:Mem,  .Operands) [result(MemOffset)]

  rule <k>
    execinstr (shrdw %cl, R2:R16,  memOffset( MemOff:MInt):MemOffset,  .Operands)  =>
      loadFromMemory( MemOff, 16) ~>
      execinstr (shrdw %cl, R2,  memOffset( MemOff),  .Operands)
  ...</k>

  rule <k>
    memLoadValue(Mem16:MInt):MemLoadValue ~>  
        execinstr (shrdw %cl, R2:R16, memOffset( MemOff:MInt):MemOffset,  .Operands) =>  
      execinstr (shrdw memOffset( MemOff), Mem16, getRegisterValue(R2, RSMap), 
          shiftCountMask(getRegisterValue(%cl, RSMap), 32),  .Operands)
  ...</k>
    <regstate> RSMap </regstate>

  rule <k>
    execinstr (shrdw memOffset( MemOff), MIdest:MInt, MIsrc:MInt, MIcount:MInt, .Operands) => .
  ...</k> 
    requires eqMInt(MIcount, mi(bitwidthMInt(MIcount), 0))

  rule <k>
    execinstr (shrdw memOffset( MemOff), MIdest:MInt, MIsrc:MInt, MIcount:MInt, .Operands) => storeToMemory(undefMInt16, MemOff, 16)
  ...</k> 
   <regstate>
  RSMap:Map => updateMap(RSMap,
    "ZF" |-> (undefMInt)
    "SF" |-> (undefMInt)
    "CF" |-> (undefMInt)
    "OF" |-> (undefMInt)
    "PF" |-> (undefMInt)
    "AF" |-> (undefMInt)
  )
   </regstate>
      requires ugtMInt(MIcount, mi(bitwidthMInt(MIcount), bitwidthMInt(MIdest)))


  rule <k>
    execinstr (shrdw memOffset( MemOff), MIdest:MInt, MIsrc:MInt, MIcount:MInt, .Operands) => 
      execinstr (shrdw memOffset( MemOff), MIdest:MInt, MIsrc:MInt, MIcount:MInt, 
	orMInt( lshrMInt(MIdest, uvalueMInt(MIcount)),
      shiftLeftMInt(MIsrc, bitwidthMInt(MIdest) -Int uvalueMInt(MIcount))),
          .Operands) 
  ...</k> 
      requires uleMInt(MIcount, mi(bitwidthMInt(MIcount), bitwidthMInt(MIdest)))
       andBool (notBool eqMInt(MIcount, mi(bitwidthMInt(MIcount), 0)))

  rule <k>
    execinstr (shrdw memOffset( MemOff), MIdest:MInt, MIsrc:MInt, MIcount:MInt, MIresult:MInt, .Operands) => 
      setFlag(extractMInt(MIdest, bitwidthMInt(MIdest) -Int uvalueMInt(MIcount), bitwidthMInt(MIdest) -Int uvalueMInt(MIcount) +Int 1), "CF") ~> 
      updateSignFlag(MIresult) ~> 
      updateZeroFlag(MIresult) ~> 
      updateParityFlag(MIresult) ~> 

      setFlag(xorMInt(extractMInt(MIdest, 0, 1), extractMInt(MIresult, 0, 1)), "OF") ~>
      setFlag(undefMInt, "AF") ~> 
      storeToMemory(MIresult, MemOff, 16)
  ...</k> 
      requires eqMInt(MIcount, mi(bitwidthMInt(MIcount), 1))
  
  rule <k>
    execinstr (shrdw memOffset( MemOff), MIdest:MInt, MIsrc:MInt, MIcount:MInt, MIresult:MInt, .Operands) => 
      setFlag(extractMInt(MIdest, bitwidthMInt(MIdest) -Int uvalueMInt(MIcount), bitwidthMInt(MIdest) -Int uvalueMInt(MIcount) +Int 1), "CF") ~> 
      updateSignFlag(MIresult) ~> 
      updateZeroFlag(MIresult) ~> 
      updateParityFlag(MIresult) ~> 

      setFlag(undefMInt, "OF") ~>
      setFlag(undefMInt, "AF") ~> 
      storeToMemory(MIresult, MemOff, 16)
  ...</k> 
      requires uleMInt(MIcount, mi(bitwidthMInt(MIcount), bitwidthMInt(MIdest)))
        andBool (notBool eqMInt(MIcount, mi(bitwidthMInt(MIcount), 1)))
       andBool (notBool eqMInt(MIcount, mi(bitwidthMInt(MIcount), 0)))
endmodule
